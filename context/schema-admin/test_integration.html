<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Schema Admin Integration Test</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }
    .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
    .test-pass { background: #d4edda; border-color: #c3e6cb; }
    .test-fail { background: #f8d7da; border-color: #f5c6cb; }
    .test-result { margin: 10px 0; padding: 8px; font-family: monospace; }
    pre { background: #f5f5f5; padding: 10px; border-radius: 3px; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>Schema Admin Integration Test Suite</h1>
  <p>This page tests the integration helpers generated by the Schema Admin.</p>

  <div id="testResults"></div>

  <script>
    // Sample schema for testing
    window.tacticSchema = {
      "version": 2,
      "products": {
        "Blended Tactics": {
          "product_slug": "blended-tactics",
          "platforms": ["Xandr"],
          "mediums": ["Display", "Video"],
          "kpis": ["CPM", "CTR"],
          "tactic_alias_glossary": {
            "RON": ["Run of Network"],
            "AAT": ["Advanced Audience Targeting"],
            "GEO": ["Geo Fencing", "HLM"]
          },
          "subproducts": {
            "Targeted Display": {
              "data_value": "targetedDisplay",
              "filename_stem": "targeted-display",
              "platforms": ["Xandr"],
              "tactic_types": [
                { "code": "RON", "name": "Run of Network", "aliases": [] },
                { "code": "AAT", "name": "Advanced Audience Targeting", "aliases": [] },
                { "code": "GEO", "name": "Geo Fencing", "aliases": ["HLM"] }
              ],
              "tables": [
                {
                  "title": "Monthly Performance",
                  "table_slug": "monthly-performance",
                  "filenames": ["report-targeted-display-monthly.csv"],
                  "aliases": ["monthly", "monthly-report"],
                  "headers": ["Date", "Impressions", "Clicks", "CTR", "Spend", "Conversions"]
                }
              ],
              "ai": {
                "guidelines": "Focus on tactic performance",
                "benchmarks": {
                  "CTR": { "goal": 0.08, "warn_below": 0.05, "unit": "percentage", "direction": "higher_better" }
                }
              }
            }
          },
          "ai": {
            "guidelines": "Analyze multi-tactic campaigns",
            "benchmarks": {
              "CPM": { "goal": 8.0, "warn_below": 12.0, "unit": "USD", "direction": "lower_better" }
            }
          }
        }
      }
    };

    // Integration Helper Functions (Copy from Schema Admin)
    function matchCsvToTable(filename, csvHeaders) {
      const lowercaseFilename = filename.toLowerCase();
      
      for (const [productName, product] of Object.entries(window.tacticSchema.products)) {
        for (const [subproductName, subproduct] of Object.entries(product.subproducts || {})) {
          for (const table of subproduct.tables || []) {
            // Check exact filename match
            if (table.filenames?.some(f => f.toLowerCase() === lowercaseFilename)) {
              return { product: productName, subproduct: subproductName, table: table.title, score: 100 };
            }
            
            // Check alias match  
            if (table.aliases?.some(a => a.toLowerCase() === lowercaseFilename)) {
              return { product: productName, subproduct: subproductName, table: table.title, score: 90 };
            }
            
            // Check stem-based pattern
            const expectedPattern = `report-${subproduct.filename_stem}-${slug(table.title)}.csv`;
            if (lowercaseFilename === expectedPattern.toLowerCase()) {
              return { product: productName, subproduct: subproductName, table: table.title, score: 85 };
            }
          }
        }
      }
      
      // Header similarity fallback
      if (csvHeaders && csvHeaders.length > 0) {
        let bestMatch = null;
        let highestScore = 0;
        
        for (const [productName, product] of Object.entries(window.tacticSchema.products)) {
          for (const [subproductName, subproduct] of Object.entries(product.subproducts || {})) {
            for (const table of subproduct.tables || []) {
              if (table.headers && table.headers.length > 0) {
                const similarity = jaccardSimilarity(csvHeaders, table.headers);
                if (similarity >= 0.6 && similarity > highestScore) {
                  highestScore = similarity;
                  bestMatch = { 
                    product: productName, 
                    subproduct: subproductName, 
                    table: table.title, 
                    score: Math.round(similarity * 80)
                  };
                }
              }
            }
          }
        }
        return bestMatch;
      }
      
      return null;
    }

    function generateReportLink(productName, subproductName, orderId, timePeriod = 'last30Days', format = 'web') {
      const subproduct = window.tacticSchema.products[productName]?.subproducts[subproductName];
      if (!subproduct?.data_value) return null;
      
      return `https://townsquarelumina.com/lumina/view/reports/max?reportType=${encodeURIComponent(subproduct.data_value)}&timePeriod=${encodeURIComponent(timePeriod)}&woOrderNumber=${encodeURIComponent(orderId)}&reportFormat=${encodeURIComponent(format)}`;
    }

    function generateLineItemLink(productName, lineItemId) {
      const product = window.tacticSchema.products[productName];
      if (!product?.product_slug) return null;
      
      return `https://townsquarelumina.com/lumina/view/lineitem/${product.product_slug}/${lineItemId}`;
    }

    function getEffectiveAnalysisContext(productName, subproductName = null) {
      const product = window.tacticSchema.products[productName];
      if (!product) return null;

      let context = {
        platforms: [...(product.platforms || [])],
        mediums: [...(product.mediums || [])],
        kpis: [...(product.kpis || [])],
        guidelines: product.ai?.guidelines || '',
        benchmarks: { ...(product.ai?.benchmarks || {}) }
      };

      if (subproductName && product.subproducts[subproductName]) {
        const subproduct = product.subproducts[subproductName];
        
        if (subproduct.platforms) {
          context.platforms = [...new Set([...context.platforms, ...subproduct.platforms])];
        }
        
        if (subproduct.ai?.guidelines) {
          context.guidelines = [context.guidelines, subproduct.ai.guidelines].filter(Boolean).join('\\n\\n');
        }
        
        if (subproduct.ai?.benchmarks) {
          context.benchmarks = { ...context.benchmarks, ...subproduct.ai.benchmarks };
        }
      }

      return context;
    }

    function normalizeTacticLabel(tacticLabel, productName, subproductName = null) {
      const product = window.tacticSchema.products[productName];
      if (!product) return null;

      // Check product-level glossary
      for (const [code, aliases] of Object.entries(product.tactic_alias_glossary || {})) {
        if (aliases.includes(tacticLabel) || code === tacticLabel) {
          return { code, name: aliases[0] || code };
        }
      }

      // Check subproduct tactic types
      if (subproductName && product.subproducts[subproductName]) {
        const tacticTypes = product.subproducts[subproductName].tactic_types || [];
        for (const tacticType of tacticTypes) {
          if (tacticType.code === tacticLabel || 
              tacticType.name === tacticLabel || 
              tacticType.aliases?.includes(tacticLabel)) {
            return { code: tacticType.code, name: tacticType.name };
          }
        }
      }

      return null;
    }

    function jaccardSimilarity(set1, set2) {
      const s1 = new Set(set1.map(h => h.toLowerCase().trim()));
      const s2 = new Set(set2.map(h => h.toLowerCase().trim()));
      const intersection = new Set([...s1].filter(x => s2.has(x)));
      const union = new Set([...s1, ...s2]);
      return intersection.size / union.size;
    }

    function slug(str) {
      return (str || '').toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/(^-|-$)/g, '');
    }

    // Test Suite
    function runTests() {
      const results = [];
      
      // Test 1: CSV File Routing - Exact filename match
      const test1 = matchCsvToTable("report-targeted-display-monthly.csv", null);
      results.push({
        name: "CSV Routing - Exact Filename",
        pass: test1?.product === "Blended Tactics" && test1?.score === 100,
        result: test1,
        expected: "Should match Blended Tactics > Targeted Display with score 100"
      });

      // Test 2: CSV File Routing - Header similarity
      const test2 = matchCsvToTable("unknown-file.csv", ["Date", "Impressions", "Clicks", "CTR"]);
      results.push({
        name: "CSV Routing - Header Similarity", 
        pass: test2?.product === "Blended Tactics" && test2?.score >= 60,
        result: test2,
        expected: "Should match based on header similarity"
      });

      // Test 3: Report Link Generation
      const test3 = generateReportLink("Blended Tactics", "Targeted Display", "12345");
      results.push({
        name: "Report Link Generation",
        pass: test3?.includes("targetedDisplay") && test3?.includes("12345"),
        result: test3,
        expected: "Should generate valid report URL with targetedDisplay"
      });

      // Test 4: Line Item Link Generation
      const test4 = generateLineItemLink("Blended Tactics", "abc123");
      results.push({
        name: "Line Item Link Generation",
        pass: test4?.includes("blended-tactics") && test4?.includes("abc123"),
        result: test4,
        expected: "Should generate valid line item URL"
      });

      // Test 5: Effective Context Inheritance
      const test5 = getEffectiveAnalysisContext("Blended Tactics", "Targeted Display");
      results.push({
        name: "Context Inheritance",
        pass: test5?.platforms?.includes("Xandr") && test5?.guidelines?.includes("tactic performance"),
        result: test5,
        expected: "Should inherit and merge product + subproduct context"
      });

      // Test 6: Tactic Normalization
      const test6 = normalizeTacticLabel("HLM", "Blended Tactics", "Targeted Display");
      results.push({
        name: "Tactic Alias Normalization",
        pass: test6?.code === "GEO" && test6?.name === "Geo Fencing",
        result: test6,
        expected: "Should normalize HLM alias to GEO code"
      });

      return results;
    }

    // Display Results
    function displayResults() {
      const results = runTests();
      const container = document.getElementById('testResults');
      
      results.forEach(test => {
        const div = document.createElement('div');
        div.className = `test-section ${test.pass ? 'test-pass' : 'test-fail'}`;
        
        div.innerHTML = `
          <h3>${test.name} ${test.pass ? '✅' : '❌'}</h3>
          <p><strong>Expected:</strong> ${test.expected}</p>
          <div class="test-result">
            <strong>Result:</strong>
            <pre>${JSON.stringify(test.result, null, 2)}</pre>
          </div>
        `;
        
        container.appendChild(div);
      });

      const passCount = results.filter(t => t.pass).length;
      const summary = document.createElement('div');
      summary.innerHTML = `<h2>Test Summary: ${passCount}/${results.length} tests passed</h2>`;
      container.insertBefore(summary, container.firstChild);
    }

    // Run tests when page loads
    document.addEventListener('DOMContentLoaded', displayResults);
  </script>
</body>
</html>